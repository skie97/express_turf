"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.ts
var _distance = require('@turf/distance');





var _helpers = require('@turf/helpers');
var _invariant = require('@turf/invariant');
var _meta = require('@turf/meta');
var _rhumbdistance = require('@turf/rhumb-distance');
function pointToLineDistance(pt, line, options = {}) {
  if (!options.method) {
    options.method = "geodesic";
  }
  if (!options.units) {
    options.units = "kilometers";
  }
  if (!pt) {
    throw new Error("pt is required");
  }
  if (Array.isArray(pt)) {
    pt = _helpers.point.call(void 0, pt);
  } else if (pt.type === "Point") {
    pt = _helpers.feature.call(void 0, pt);
  } else {
    _invariant.featureOf.call(void 0, pt, "Point", "point");
  }
  if (!line) {
    throw new Error("line is required");
  }
  if (Array.isArray(line)) {
    line = _helpers.lineString.call(void 0, line);
  } else if (line.type === "LineString") {
    line = _helpers.feature.call(void 0, line);
  } else {
    _invariant.featureOf.call(void 0, line, "LineString", "line");
  }
  let distance = Infinity;
  const p = pt.geometry.coordinates;
  _meta.segmentEach.call(void 0, line, (segment) => {
    const a = segment.geometry.coordinates[0];
    const b = segment.geometry.coordinates[1];
    const d = distanceToSegment(p, a, b, options);
    if (d < distance) {
      distance = d;
    }
  });
  return _helpers.convertLength.call(void 0, distance, "degrees", options.units);
}
__name(pointToLineDistance, "pointToLineDistance");
function distanceToSegment(p, a, b, options) {
  const v = [b[0] - a[0], b[1] - a[1]];
  const w = [p[0] - a[0], p[1] - a[1]];
  const c1 = dot(w, v);
  if (c1 <= 0) {
    return calcDistance(p, a, { method: options.method, units: "degrees" });
  }
  const c2 = dot(v, v);
  if (c2 <= c1) {
    return calcDistance(p, b, { method: options.method, units: "degrees" });
  }
  const b2 = c1 / c2;
  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
  return calcDistance(p, Pb, { method: options.method, units: "degrees" });
}
__name(distanceToSegment, "distanceToSegment");
function dot(u, v) {
  return u[0] * v[0] + u[1] * v[1];
}
__name(dot, "dot");
function calcDistance(a, b, options) {
  return options.method === "planar" ? _rhumbdistance.rhumbDistance.call(void 0, a, b, options) : _distance.distance.call(void 0, a, b, options);
}
__name(calcDistance, "calcDistance");
var turf_point_to_line_distance_default = pointToLineDistance;



exports.default = turf_point_to_line_distance_default; exports.pointToLineDistance = pointToLineDistance;
//# sourceMappingURL=index.cjs.map