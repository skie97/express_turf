{"version":3,"sources":["../../index.ts"],"sourcesContent":["// Taken from http://geomalgorithms.com/a02-_lines.html\nimport { Feature, LineString } from \"geojson\";\nimport { distance as getDistance } from \"@turf/distance\";\nimport {\n  convertLength,\n  Coord,\n  feature,\n  lineString,\n  point,\n  Units,\n} from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport { rhumbDistance as getPlanarDistance } from \"@turf/rhumb-distance\";\n\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(\n  pt: Coord,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    method?: \"geodesic\" | \"planar\";\n  } = {}\n): number {\n  // Optional parameters\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n  if (!options.units) {\n    options.units = \"kilometers\";\n  }\n\n  // validation\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n\n  let distance = Infinity;\n  const p = pt.geometry.coordinates;\n  segmentEach(line, (segment) => {\n    const a = segment!.geometry.coordinates[0];\n    const b = segment!.geometry.coordinates[1];\n    const d = distanceToSegment(p, a, b, options);\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return convertLength(distance, \"degrees\", options.units);\n}\n\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(\n  p: number[],\n  a: number[],\n  b: number[],\n  options: any\n) {\n  const v = [b[0] - a[0], b[1] - a[1]];\n  const w = [p[0] - a[0], p[1] - a[1]];\n\n  const c1 = dot(w, v);\n  if (c1 <= 0) {\n    return calcDistance(p, a, { method: options.method, units: \"degrees\" });\n  }\n  const c2 = dot(v, v);\n  if (c2 <= c1) {\n    return calcDistance(p, b, { method: options.method, units: \"degrees\" });\n  }\n  const b2 = c1 / c2;\n  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\n}\n\nfunction dot(u: number[], v: number[]) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n\nfunction calcDistance(a: number[], b: number[], options: any) {\n  return options.method === \"planar\"\n    ? getPlanarDistance(a, b, options)\n    : getDistance(a, b, options);\n}\n\nexport { pointToLineDistance };\nexport default pointToLineDistance;\n"],"mappings":";;;;AAEA,SAAS,YAAY,mBAAmB;AACxC;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,OAEK;AACP,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB,yBAAyB;AAsBnD,SAAS,oBACP,IACA,MACA,UAGI,CAAC,GACG;AAER,MAAI,CAAC,QAAQ,QAAQ;AACnB,YAAQ,SAAS;AAAA,EACnB;AACA,MAAI,CAAC,QAAQ,OAAO;AAClB,YAAQ,QAAQ;AAAA,EAClB;AAGA,MAAI,CAAC,IAAI;AACP,UAAM,IAAI,MAAM,gBAAgB;AAAA,EAClC;AACA,MAAI,MAAM,QAAQ,EAAE,GAAG;AACrB,SAAK,MAAM,EAAE;AAAA,EACf,WAAW,GAAG,SAAS,SAAS;AAC9B,SAAK,QAAQ,EAAE;AAAA,EACjB,OAAO;AACL,cAAU,IAAI,SAAS,OAAO;AAAA,EAChC;AAEA,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AACA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO,WAAW,IAAI;AAAA,EACxB,WAAW,KAAK,SAAS,cAAc;AACrC,WAAO,QAAQ,IAAI;AAAA,EACrB,OAAO;AACL,cAAU,MAAM,cAAc,MAAM;AAAA,EACtC;AAEA,MAAI,WAAW;AACf,QAAM,IAAI,GAAG,SAAS;AACtB,cAAY,MAAM,CAAC,YAAY;AAC7B,UAAM,IAAI,QAAS,SAAS,YAAY,CAAC;AACzC,UAAM,IAAI,QAAS,SAAS,YAAY,CAAC;AACzC,UAAM,IAAI,kBAAkB,GAAG,GAAG,GAAG,OAAO;AAC5C,QAAI,IAAI,UAAU;AAChB,iBAAW;AAAA,IACb;AAAA,EACF,CAAC;AACD,SAAO,cAAc,UAAU,WAAW,QAAQ,KAAK;AACzD;AAlDS;AA8DT,SAAS,kBACP,GACA,GACA,GACA,SACA;AACA,QAAM,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AACnC,QAAM,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAEnC,QAAM,KAAK,IAAI,GAAG,CAAC;AACnB,MAAI,MAAM,GAAG;AACX,WAAO,aAAa,GAAG,GAAG,EAAE,QAAQ,QAAQ,QAAQ,OAAO,UAAU,CAAC;AAAA,EACxE;AACA,QAAM,KAAK,IAAI,GAAG,CAAC;AACnB,MAAI,MAAM,IAAI;AACZ,WAAO,aAAa,GAAG,GAAG,EAAE,QAAQ,QAAQ,QAAQ,OAAO,UAAU,CAAC;AAAA,EACxE;AACA,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,CAAC;AAC9C,SAAO,aAAa,GAAG,IAAI,EAAE,QAAQ,QAAQ,QAAQ,OAAO,UAAU,CAAC;AACzE;AApBS;AAsBT,SAAS,IAAI,GAAa,GAAa;AACrC,SAAO,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AACjC;AAFS;AAIT,SAAS,aAAa,GAAa,GAAa,SAAc;AAC5D,SAAO,QAAQ,WAAW,WACtB,kBAAkB,GAAG,GAAG,OAAO,IAC/B,YAAY,GAAG,GAAG,OAAO;AAC/B;AAJS;AAOT,IAAO,sCAAQ;","names":[]}