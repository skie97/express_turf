{"version":3,"sources":["../../index.js"],"names":["voronoi"],"mappings":";;;;AAAA,SAAS,SAAS,mBAAmB,gBAAgB;AACrD,SAAS,oBAAoB;AAC7B,SAAS,uBAAuB;AAChC,YAAY,eAAe;AAO3B,SAAS,gBAAgB,QAAQ;AAC/B,WAAS,OAAO,MAAM;AACtB,SAAO,KAAK,OAAO,CAAC,CAAC;AACrB,SAAO,QAAQ,CAAC,MAAM,CAAC;AACzB;AAJS;AA2BT,SAASA,SAAQ,QAAQ,SAAS;AAEhC,YAAU,WAAW,CAAC;AACtB,MAAI,CAAC,SAAS,OAAO;AAAG,UAAM,IAAI,MAAM,oBAAoB;AAC5D,MAAI,OAAO,QAAQ,QAAQ,CAAC,MAAM,KAAK,KAAK,EAAE;AAG9C,MAAI,CAAC;AAAQ,UAAM,IAAI,MAAM,oBAAoB;AACjD,MAAI,CAAC,MAAM,QAAQ,IAAI;AAAG,UAAM,IAAI,MAAM,iBAAiB;AAC3D,eAAa,QAAQ,SAAS,QAAQ;AAGtC,SAAO;AAAA,IAEF,kBAAQ,EACR,EAAE,SAAU,SAAS;AACpB,aAAO,QAAQ,SAAS,YAAY,CAAC;AAAA,IACvC,CAAC,EACA,EAAE,SAAU,SAAS;AACpB,aAAO,QAAQ,SAAS,YAAY,CAAC;AAAA,IACvC,CAAC,EACA,OAAO;AAAA,MACN,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,MACjB,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IACnB,CAAC,EACA,SAAS,OAAO,QAAQ,EACxB,IAAI,SAAU,QAAQ,OAAO;AAC5B,aAAO,OAAO,OAAO,gBAAgB,MAAM,GAAG;AAAA,QAC5C,YAAY,gBAAgB,OAAO,SAAS,KAAK,EAAE,UAAU;AAAA,MAC/D,CAAC;AAAA,IACH,CAAC;AAAA,EACL;AACF;AAhCS,OAAAA,UAAA;AAmCT,IAAO,uBAAQA","sourcesContent":["import { polygon, featureCollection, isObject } from \"@turf/helpers\";\nimport { collectionOf } from \"@turf/invariant\";\nimport { cloneProperties } from \"@turf/clone\";\nimport * as d3voronoi from \"d3-voronoi\";\n\n/**\n * @private\n * @param {Array<Array<number>>} coords representing a polygon\n * @returns {Feature<Polygon>} polygon\n */\nfunction coordsToPolygon(coords) {\n  coords = coords.slice();\n  coords.push(coords[0]);\n  return polygon([coords]);\n}\n\n/**\n * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection\n * of Voronoi polygons.\n *\n * The Voronoi algorithim used comes from the d3-voronoi package.\n *\n * @name voronoi\n * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.\n * @param {Object} [options={}] Optional parameters\n * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.\n * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.\n * @example\n * var options = {\n *   bbox: [-70, 40, -60, 60]\n * };\n * var points = turf.randomPoint(100, options);\n * var voronoiPolygons = turf.voronoi(points, options);\n *\n * //addToMap\n * var addToMap = [voronoiPolygons, points];\n */\nfunction voronoi(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var bbox = options.bbox || [-180, -85, 180, 85];\n\n  // Input Validation\n  if (!points) throw new Error(\"points is required\");\n  if (!Array.isArray(bbox)) throw new Error(\"bbox is invalid\");\n  collectionOf(points, \"Point\", \"points\");\n\n  // Main\n  return featureCollection(\n    d3voronoi\n      .voronoi()\n      .x(function (feature) {\n        return feature.geometry.coordinates[0];\n      })\n      .y(function (feature) {\n        return feature.geometry.coordinates[1];\n      })\n      .extent([\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[3]],\n      ])\n      .polygons(points.features)\n      .map(function (coords, index) {\n        return Object.assign(coordsToPolygon(coords), {\n          properties: cloneProperties(points.features[index].properties),\n        });\n      })\n  );\n}\n\nexport { voronoi };\nexport default voronoi;\n"]}