{"version":3,"sources":["../../index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Feature, Geometry, LineString, Point, Polygon } from \"geojson\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { lineIntersect } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { polygonToLine } from \"@turf/polygon-to-line\";\n\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(\n  feature1: Feature<any> | Geometry,\n  feature2: Feature<any> | Geometry\n): boolean {\n  let bool = true;\n  flattenEach(feature1, (flatten1) => {\n    flattenEach(feature2, (flatten2) => {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(flatten1.geometry, flatten2.geometry);\n    });\n  });\n  return bool;\n}\n\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1: any, geom2: any) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1);\n      }\n  }\n  return false;\n}\n\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString: LineString, pt: Point) {\n  for (let i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (\n      isPointOnLineSegment(\n        lineString.coordinates[i],\n        lineString.coordinates[i + 1],\n        pt.coordinates\n      )\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isLineOnLine(lineString1: LineString, lineString2: LineString) {\n  const doLinesIntersect = lineIntersect(lineString1, lineString2);\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isLineInPoly(polygon: Polygon, lineString: LineString) {\n  for (const coord of lineString.coordinates) {\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1: Polygon, feature2: Polygon) {\n  for (const coord1 of feature1.coordinates[0]) {\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (const coord2 of feature2.coordinates[0]) {\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  const doLinesIntersect = lineIntersect(\n    polygonToLine(feature1),\n    polygonToLine(feature2)\n  );\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n\nfunction isPointOnLineSegment(\n  lineSegmentStart: number[],\n  lineSegmentEnd: number[],\n  pt: number[]\n) {\n  const dxc = pt[0] - lineSegmentStart[0];\n  const dyc = pt[1] - lineSegmentStart[1];\n  const dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  const dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  const cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\n\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1: number[], pair2: number[]) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n\nexport { booleanDisjoint };\nexport default booleanDisjoint;\n"]}