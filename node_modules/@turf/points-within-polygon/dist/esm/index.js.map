{"version":3,"sources":["../../index.ts"],"sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  MultiPolygon,\n  MultiPoint,\n  Point,\n  GeoJsonProperties,\n  Position,\n} from \"geojson\";\nimport { booleanPointInPolygon as pointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, multiPoint } from \"@turf/helpers\";\nimport { geomEach, featureEach, coordEach } from \"@turf/meta\";\n\n/**\n * Finds {@link Points} or {@link MultiPoint} coordinate positions that fall within {@link (Multi)Polygon(s)}.\n *\n * @name pointsWithinPolygon\n * @param {Feature|FeatureCollection<Point|MultiPoint>} points Point(s) or MultiPoint(s) as input search\n * @param {FeatureCollection|Geometry|Feature<Polygon|MultiPolygon>} polygons (Multi)Polygon(s) to check if points are within\n * @returns {FeatureCollection<Point|MultiPoint>} Point(s) or MultiPoint(s) with positions that land within at least one polygon.  The geometry type will match what was passsed in\n * @example\n * var points = turf.points([\n *     [-46.6318, -23.5523],\n *     [-46.6246, -23.5325],\n *     [-46.6062, -23.5513],\n *     [-46.663, -23.554],\n *     [-46.643, -23.557]\n * ]);\n *\n * var searchWithin = turf.polygon([[\n *     [-46.653,-23.543],\n *     [-46.634,-23.5346],\n *     [-46.613,-23.543],\n *     [-46.614,-23.559],\n *     [-46.631,-23.567],\n *     [-46.653,-23.560],\n *     [-46.653,-23.543]\n * ]]);\n *\n * var ptsWithin = turf.pointsWithinPolygon(points, searchWithin);\n *\n * //addToMap\n * var addToMap = [points, searchWithin, ptsWithin]\n * turf.featureEach(ptsWithin, function (currentFeature) {\n *   currentFeature.properties['marker-size'] = 'large';\n *   currentFeature.properties['marker-color'] = '#000';\n * });\n */\nfunction pointsWithinPolygon<\n  G extends Polygon | MultiPolygon,\n  P extends GeoJsonProperties,\n>(\n  points:\n    | Feature<Point | MultiPoint, P>\n    | FeatureCollection<Point | MultiPoint, P>,\n  polygons: Feature<G> | FeatureCollection<G> | G\n): FeatureCollection<Point | MultiPoint, P> {\n  const results: Feature<Point | MultiPoint, P>[] = [];\n  featureEach(points, function (point) {\n    let contained = false;\n    if (point.geometry.type === \"Point\") {\n      geomEach(polygons, function (polygon) {\n        if (pointInPolygon(point as Feature<Point, P>, polygon)) {\n          contained = true;\n        }\n      });\n      if (contained) {\n        results.push(point);\n      }\n    } else if (point.geometry.type === \"MultiPoint\") {\n      var pointsWithin: Position[] = [];\n      geomEach(polygons, function (polygon) {\n        coordEach(point as Feature<MultiPoint>, function (pointCoord) {\n          if (pointInPolygon(pointCoord, polygon)) {\n            contained = true;\n            pointsWithin.push(pointCoord);\n          }\n        });\n      });\n      if (contained) {\n        results.push(\n          multiPoint(pointsWithin, point.properties) as Feature<MultiPoint, P>\n        );\n      }\n    } else {\n      throw new Error(\"Input geometry must be a Point or MultiPoint\");\n    }\n  });\n  return featureCollection(results);\n}\n\nexport { pointsWithinPolygon };\nexport default pointsWithinPolygon;\n"],"mappings":";;;;AAUA,SAAS,yBAAyB,sBAAsB;AACxD,SAAS,mBAAmB,kBAAkB;AAC9C,SAAS,UAAU,aAAa,iBAAiB;AAqCjD,SAAS,oBAIP,QAGA,UAC0C;AAC1C,QAAM,UAA4C,CAAC;AACnD,cAAY,QAAQ,SAAU,OAAO;AACnC,QAAI,YAAY;AAChB,QAAI,MAAM,SAAS,SAAS,SAAS;AACnC,eAAS,UAAU,SAAU,SAAS;AACpC,YAAI,eAAe,OAA4B,OAAO,GAAG;AACvD,sBAAY;AAAA,QACd;AAAA,MACF,CAAC;AACD,UAAI,WAAW;AACb,gBAAQ,KAAK,KAAK;AAAA,MACpB;AAAA,IACF,WAAW,MAAM,SAAS,SAAS,cAAc;AAC/C,UAAI,eAA2B,CAAC;AAChC,eAAS,UAAU,SAAU,SAAS;AACpC,kBAAU,OAA8B,SAAU,YAAY;AAC5D,cAAI,eAAe,YAAY,OAAO,GAAG;AACvC,wBAAY;AACZ,yBAAa,KAAK,UAAU;AAAA,UAC9B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AACD,UAAI,WAAW;AACb,gBAAQ;AAAA,UACN,WAAW,cAAc,MAAM,UAAU;AAAA,QAC3C;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAAA,EACF,CAAC;AACD,SAAO,kBAAkB,OAAO;AAClC;AAzCS;AA4CT,IAAO,qCAAQ;","names":[]}