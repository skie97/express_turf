var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.ts
import {
  featureCollection,
  isNumber,
  isObject,
  lineString,
  point,
  polygon,
  validateBBox
} from "@turf/helpers";
function randomPosition(bbox) {
  checkBBox(bbox);
  return randomPositionUnchecked(bbox);
}
__name(randomPosition, "randomPosition");
function randomPositionUnchecked(bbox) {
  if (Array.isArray(bbox)) {
    return coordInBBox(bbox);
  }
  if (bbox && bbox.bbox) {
    return coordInBBox(bbox.bbox);
  }
  return [lon(), lat()];
}
__name(randomPositionUnchecked, "randomPositionUnchecked");
function checkBBox(bbox) {
  if (bbox == null) {
    return;
  } else if (Array.isArray(bbox)) {
    validateBBox(bbox);
  } else if (bbox.bbox != null) {
    validateBBox(bbox.bbox);
  }
}
__name(checkBBox, "checkBBox");
function randomPoint(count, options = {}) {
  checkBBox(options.bbox);
  if (count === void 0 || count === null) {
    count = 1;
  }
  const features = [];
  for (let i = 0; i < count; i++) {
    features.push(point(randomPositionUnchecked(options.bbox)));
  }
  return featureCollection(features);
}
__name(randomPoint, "randomPoint");
function randomPolygon(count, options = {}) {
  checkBBox(options.bbox);
  if (count === void 0 || count === null) {
    count = 1;
  }
  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {
    options.num_vertices = 10;
  }
  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {
    options.max_radial_length = 10;
  }
  const features = [];
  for (let i = 0; i < count; i++) {
    let vertices = [];
    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);
    circleOffsets.forEach((cur, index, arr) => {
      arr[index] = index > 0 ? cur + arr[index - 1] : cur;
    });
    circleOffsets.forEach((cur) => {
      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];
      const radialScaler = Math.random();
      vertices.push([
        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),
        radialScaler * (options.max_radial_length || 10) * Math.cos(cur)
      ]);
    });
    vertices[vertices.length - 1] = vertices[0];
    vertices = vertices.map(
      vertexToCoordinate(randomPositionUnchecked(options.bbox))
    );
    features.push(polygon([vertices]));
  }
  return featureCollection(features);
}
__name(randomPolygon, "randomPolygon");
function randomLineString(count, options = {}) {
  options = options || {};
  if (!isObject(options)) {
    throw new Error("options is invalid");
  }
  const bbox = options.bbox;
  checkBBox(bbox);
  let num_vertices = options.num_vertices;
  let max_length = options.max_length;
  let max_rotation = options.max_rotation;
  if (count === void 0 || count === null) {
    count = 1;
  }
  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {
    num_vertices = 10;
  }
  if (!isNumber(max_length) || max_length === void 0) {
    max_length = 1e-4;
  }
  if (!isNumber(max_rotation) || max_rotation === void 0) {
    max_rotation = Math.PI / 8;
  }
  const features = [];
  for (let i = 0; i < count; i++) {
    const startingPoint = randomPositionUnchecked(bbox);
    const vertices = [startingPoint];
    for (let j = 0; j < num_vertices - 1; j++) {
      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan(
        (vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0])
      );
      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;
      const distance = Math.random() * max_length;
      vertices.push([
        vertices[j][0] + distance * Math.cos(angle),
        vertices[j][1] + distance * Math.sin(angle)
      ]);
    }
    features.push(lineString(vertices));
  }
  return featureCollection(features);
}
__name(randomLineString, "randomLineString");
function vertexToCoordinate(hub) {
  return (cur) => {
    return [cur[0] + hub[0], cur[1] + hub[1]];
  };
}
__name(vertexToCoordinate, "vertexToCoordinate");
function rnd() {
  return Math.random() - 0.5;
}
__name(rnd, "rnd");
function lon() {
  return rnd() * 360;
}
__name(lon, "lon");
function lat() {
  return rnd() * 180;
}
__name(lat, "lat");
function coordInBBox(bbox) {
  return [
    Math.random() * (bbox[2] - bbox[0]) + bbox[0],
    Math.random() * (bbox[3] - bbox[1]) + bbox[1]
  ];
}
__name(coordInBBox, "coordInBBox");
export {
  randomLineString,
  randomPoint,
  randomPolygon,
  randomPosition
};
//# sourceMappingURL=index.js.map