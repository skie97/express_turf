{"version":3,"sources":["../../index.js"],"sourcesContent":["import { centroid } from \"@turf/centroid\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { clone } from \"@turf/clone\";\nimport { coordEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { isObject } from \"@turf/helpers\";\n\n/**\n * Rotates any geojson Feature or Geometry of a specified angle, around its `centroid` or a given `pivot` point.\n *\n * @name transformRotate\n * @param {GeoJSON} geojson object to be rotated\n * @param {number} angle of rotation in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {Coord} [options.pivot='centroid'] point around which the rotation will be performed\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the rotated GeoJSON feature\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var options = {pivot: [0, 25]};\n * var rotatedPoly = turf.transformRotate(poly, 10, options);\n *\n * //addToMap\n * var addToMap = [poly, rotatedPoly];\n * rotatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformRotate(geojson, angle, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var pivot = options.pivot;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (angle === undefined || angle === null || isNaN(angle))\n    throw new Error(\"angle is required\");\n\n  // Shortcut no-rotation\n  if (angle === 0) return geojson;\n\n  // Use centroid of GeoJSON if pivot is not provided\n  if (!pivot) pivot = centroid(geojson);\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Rotate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    var initialAngle = rhumbBearing(pivot, pointCoords);\n    var finalAngle = initialAngle + angle;\n    var distance = rhumbDistance(pivot, pointCoords);\n    var newCoords = getCoords(rhumbDestination(pivot, distance, finalAngle));\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n  });\n  return geojson;\n}\n\nexport { transformRotate };\nexport default transformRotate;\n"],"mappings":";;;;AAAA,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAC7B,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB;AACjC,SAAS,aAAa;AACtB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AAqBzB,SAAS,gBAAgB,SAAS,OAAO,SAAS;AAEhD,YAAU,WAAW,CAAC;AACtB,MAAI,CAAC,SAAS,OAAO;AAAG,UAAM,IAAI,MAAM,oBAAoB;AAC5D,MAAI,QAAQ,QAAQ;AACpB,MAAI,SAAS,QAAQ;AAGrB,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,qBAAqB;AACnD,MAAI,UAAU,UAAa,UAAU,QAAQ,MAAM,KAAK;AACtD,UAAM,IAAI,MAAM,mBAAmB;AAGrC,MAAI,UAAU;AAAG,WAAO;AAGxB,MAAI,CAAC;AAAO,YAAQ,SAAS,OAAO;AAGpC,MAAI,WAAW,SAAS,WAAW;AAAW,cAAU,MAAM,OAAO;AAGrE,YAAU,SAAS,SAAU,aAAa;AACxC,QAAI,eAAe,aAAa,OAAO,WAAW;AAClD,QAAI,aAAa,eAAe;AAChC,QAAI,WAAW,cAAc,OAAO,WAAW;AAC/C,QAAI,YAAY,UAAU,iBAAiB,OAAO,UAAU,UAAU,CAAC;AACvE,gBAAY,CAAC,IAAI,UAAU,CAAC;AAC5B,gBAAY,CAAC,IAAI,UAAU,CAAC;AAAA,EAC9B,CAAC;AACD,SAAO;AACT;AA/BS;AAkCT,IAAO,gCAAQ;","names":[]}