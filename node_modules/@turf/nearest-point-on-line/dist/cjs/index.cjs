"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.ts
var _bearing = require('@turf/bearing');
var _distance = require('@turf/distance');
var _destination = require('@turf/destination');
var _lineintersect = require('@turf/line-intersect');
var _meta = require('@turf/meta');
var _helpers = require('@turf/helpers');
var _invariant = require('@turf/invariant');
function nearestPointOnLine(lines, pt, options = {}) {
  if (!lines || !pt) {
    throw new Error("lines and pt are required arguments");
  }
  let closestPt = _helpers.point.call(void 0, [Infinity, Infinity], {
    dist: Infinity,
    index: -1,
    location: -1
  });
  let length = 0;
  _meta.flattenEach.call(void 0, lines, function(line) {
    const coords = _invariant.getCoords.call(void 0, line);
    for (let i = 0; i < coords.length - 1; i++) {
      const start = _helpers.point.call(void 0, coords[i]);
      start.properties.dist = _distance.distance.call(void 0, pt, start, options);
      const stop = _helpers.point.call(void 0, coords[i + 1]);
      stop.properties.dist = _distance.distance.call(void 0, pt, stop, options);
      const sectionLength = _distance.distance.call(void 0, start, stop, options);
      const heightDistance = Math.max(
        start.properties.dist,
        stop.properties.dist
      );
      const direction = _bearing.bearing.call(void 0, start, stop);
      const perpendicularPt1 = _destination.destination.call(void 0, 
        pt,
        heightDistance,
        direction + 90,
        options
      );
      const perpendicularPt2 = _destination.destination.call(void 0, 
        pt,
        heightDistance,
        direction - 90,
        options
      );
      const intersect = _lineintersect.lineIntersect.call(void 0, 
        _helpers.lineString.call(void 0, [
          perpendicularPt1.geometry.coordinates,
          perpendicularPt2.geometry.coordinates
        ]),
        _helpers.lineString.call(void 0, [start.geometry.coordinates, stop.geometry.coordinates])
      );
      let intersectPt;
      if (intersect.features.length > 0 && intersect.features[0]) {
        intersectPt = __spreadProps(__spreadValues({}, intersect.features[0]), {
          properties: {
            dist: _distance.distance.call(void 0, pt, intersect.features[0], options),
            location: length + _distance.distance.call(void 0, start, intersect.features[0], options)
          }
        });
      }
      if (start.properties.dist < closestPt.properties.dist) {
        closestPt = __spreadProps(__spreadValues({}, start), {
          properties: __spreadProps(__spreadValues({}, start.properties), { index: i, location: length })
        });
      }
      if (stop.properties.dist < closestPt.properties.dist) {
        closestPt = __spreadProps(__spreadValues({}, stop), {
          properties: __spreadProps(__spreadValues({}, stop.properties), {
            index: i + 1,
            location: length + sectionLength
          })
        });
      }
      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
        closestPt = __spreadProps(__spreadValues({}, intersectPt), {
          properties: __spreadProps(__spreadValues({}, intersectPt.properties), { index: i })
        });
      }
      length += sectionLength;
    }
  });
  return closestPt;
}
__name(nearestPointOnLine, "nearestPointOnLine");
var turf_nearest_point_on_line_default = nearestPointOnLine;



exports.default = turf_nearest_point_on_line_default; exports.nearestPointOnLine = nearestPointOnLine;
//# sourceMappingURL=index.cjs.map