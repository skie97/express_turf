{"version":3,"sources":["../../index.ts"],"names":["poly"],"mappings":"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","sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  Polygon,\n  Position,\n  MultiPolygon,\n} from \"geojson\";\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @name polygonSmooth\n * @param {FeatureCollection<Polygon|MultiPolygon>|Feature<Polygon|MultiPolygon>|Polygon|MultiPolygon} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] The number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon|MultiPolygon>} FeatureCollection containing the smoothed polygon/multipoylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(\n  inputPolys:\n    | FeatureCollection<Polygon | MultiPolygon>\n    | Feature<Polygon | MultiPolygon>\n    | Polygon\n    | MultiPolygon,\n  options?: {\n    iterations?: number;\n  }\n): FeatureCollection<Polygon | MultiPolygon> {\n  // Optional parameters\n  options = options || {};\n  options.iterations = options.iterations || 1;\n\n  const { iterations } = options;\n\n  const outPolys: Feature<Polygon | MultiPolygon>[] = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords: Position[][] = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput: Position[][] = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords: Position[][][] = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput: Position[][][] = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly: Polygon, tempOutput: Position[][]) {\n  var previousCoord: Position;\n  var previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousGeometryIndex !== geometryIndex) {\n        tempOutput.push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly: MultiPolygon, tempOutput: Position[][][]) {\n  let previousCoord: Position;\n  let previousMultiFeatureIndex: number;\n  let previousGeometryIndex: number;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (previousMultiFeatureIndex !== multiFeatureIndex) {\n        tempOutput.push([[]]);\n      } else if (previousGeometryIndex !== geometryIndex) {\n        tempOutput[multiFeatureIndex].push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y,\n        ]);\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y,\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousMultiFeatureIndex = multiFeatureIndex;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport { polygonSmooth };\nexport default polygonSmooth;\n"]}