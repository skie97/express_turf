{"version":3,"sources":["../../lib/geojson-equality.ts","../../index.ts"],"sourcesContent":["import {\n  Feature,\n  LineString,\n  Position,\n  GeoJSON,\n  Point,\n  Polygon,\n  GeometryCollection,\n  FeatureCollection,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n} from \"geojson\";\nimport equal from \"deep-equal\";\n\n/**\n\n * GeoJSON equality checking utility.\n * Adapted from https://github.com/geosquare/geojson-equality\n *\n * @memberof helpers\n * @type {Class}\n */\nexport class GeojsonEquality {\n  private precision: number;\n  private direction = false;\n  private compareProperties = true;\n\n  constructor(opts?: {\n    precision?: number;\n    direction?: boolean;\n    compareProperties?: boolean;\n  }) {\n    this.precision = 10 ** -(opts?.precision ?? 17);\n    this.direction = opts?.direction ?? false;\n    this.compareProperties = opts?.compareProperties ?? true;\n  }\n\n  compare(g1: GeoJSON, g2: GeoJSON): boolean {\n    if (g1.type !== g2.type) {\n      return false;\n    }\n\n    if (!sameLength(g1, g2)) {\n      return false;\n    }\n\n    switch (g1.type) {\n      case \"Point\":\n        return this.compareCoord(g1.coordinates, (g2 as Point).coordinates);\n      case \"LineString\":\n        return this.compareLine(g1.coordinates, (g2 as LineString).coordinates);\n      case \"Polygon\":\n        return this.comparePolygon(g1, g2 as Polygon);\n      case \"GeometryCollection\":\n        return this.compareGeometryCollection(g1, g2 as GeometryCollection);\n      case \"Feature\":\n        return this.compareFeature(g1, g2 as Feature);\n      case \"FeatureCollection\":\n        return this.compareFeatureCollection(g1, g2 as FeatureCollection);\n      default:\n        if (g1.type.startsWith(\"Multi\")) {\n          const g1s = explode(g1);\n          const g2s = explode(\n            g2 as MultiLineString | MultiPoint | MultiPolygon\n          );\n          return g1s.every((g1part) =>\n            g2s.some((g2part) => this.compare(g1part as any, g2part as any))\n          );\n        }\n    }\n    return false;\n  }\n\n  private compareCoord(c1: Position, c2: Position) {\n    return (\n      c1.length === c2.length &&\n      c1.every((c, i) => Math.abs(c - c2[i]) < this.precision)\n    );\n  }\n\n  private compareLine(\n    path1: Position[],\n    path2: Position[],\n    ind = 0,\n    isPoly = false\n  ): boolean {\n    if (!sameLength(path1, path2)) {\n      return false;\n    }\n    const p1 = path1;\n    let p2 = path2;\n    if (isPoly && !this.compareCoord(p1[0], p2[0])) {\n      // fix start index of both to same point\n      const startIndex = this.fixStartIndex(p2, p1);\n      if (!startIndex) {\n        return false;\n      } else {\n        p2 = startIndex;\n      }\n    }\n    // for linestring ind =0 and for polygon ind =1\n    const sameDirection = this.compareCoord(p1[ind], p2[ind]);\n    if (this.direction || sameDirection) {\n      return this.comparePath(p1, p2);\n    } else {\n      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {\n        return this.comparePath(p1.slice().reverse(), p2);\n      }\n      return false;\n    }\n  }\n\n  private fixStartIndex(sourcePath: Position[], targetPath: Position[]) {\n    //make sourcePath first point same as of targetPath\n    let correctPath,\n      ind = -1;\n    for (let i = 0; i < sourcePath.length; i++) {\n      if (this.compareCoord(sourcePath[i], targetPath[0])) {\n        ind = i;\n        break;\n      }\n    }\n    if (ind >= 0) {\n      correctPath = ([] as Position[]).concat(\n        sourcePath.slice(ind, sourcePath.length),\n        sourcePath.slice(1, ind + 1)\n      );\n    }\n    return correctPath;\n  }\n\n  private comparePath(p1: Position[], p2: Position[]) {\n    return p1.every((c, i) => this.compareCoord(c, p2[i]));\n  }\n\n  private comparePolygon(g1: Polygon, g2: Polygon) {\n    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {\n      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);\n      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);\n      return holes1.every((h1) =>\n        holes2.some((h2) => this.compareLine(h1, h2, 1, true))\n      );\n    }\n    return false;\n  }\n\n  private compareGeometryCollection(\n    g1: GeometryCollection,\n    g2: GeometryCollection\n  ) {\n    return (\n      sameLength(g1.geometries, g2.geometries) &&\n      this.compareBBox(g1, g2) &&\n      g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]))\n    );\n  }\n\n  private compareFeature(g1: Feature, g2: Feature) {\n    return (\n      g1.id === g2.id &&\n      (this.compareProperties ? equal(g1.properties, g2.properties) : true) &&\n      this.compareBBox(g1, g2) &&\n      this.compare(g1.geometry, g2.geometry)\n    );\n  }\n\n  private compareFeatureCollection(\n    g1: FeatureCollection,\n    g2: FeatureCollection\n  ) {\n    return (\n      sameLength(g1.features, g2.features) &&\n      this.compareBBox(g1, g2) &&\n      g1.features.every((f, i) => this.compare(f, g2.features[i]))\n    );\n  }\n\n  private compareBBox(g1: GeoJSON, g2: GeoJSON): boolean {\n    return (\n      Boolean(!g1.bbox && !g2.bbox) ||\n      (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false)\n    );\n  }\n}\n\nfunction sameLength(g1: any, g2: any) {\n  return g1.coordinates\n    ? g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\nfunction explode(g: MultiLineString | MultiPoint | MultiPolygon) {\n  return g.coordinates.map((part) => ({\n    type: g.type.replace(\"Multi\", \"\"),\n    coordinates: part,\n  }));\n}\n","import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  GeometryCollection,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n  GeoJsonProperties,\n} from \"geojson\";\n\nimport { Id } from \"./lib/geojson.js\";\nexport * from \"./lib/geojson.js\";\nexport * from \"./lib/geojson-equality.js\";\n\n// TurfJS Combined Types\nexport type Coord = Feature<Point> | Point | Position;\n\n// TurfJS String Types\nexport type Units =\n  | \"meters\"\n  | \"metres\"\n  | \"millimeters\"\n  | \"millimetres\"\n  | \"centimeters\"\n  | \"centimetres\"\n  | \"kilometers\"\n  | \"kilometres\"\n  | \"miles\"\n  | \"nauticalmiles\"\n  | \"inches\"\n  | \"yards\"\n  | \"feet\"\n  | \"radians\"\n  | \"degrees\";\nexport type AreaUnits =\n  | Exclude<Units, \"radians\" | \"degrees\">\n  | \"acres\"\n  | \"hectares\";\nexport type Grid = \"point\" | \"square\" | \"hex\" | \"triangle\";\nexport type Corners = \"sw\" | \"se\" | \"nw\" | \"ne\" | \"center\" | \"centroid\";\n\nexport type Lines = LineString | MultiLineString | Polygon | MultiPolygon;\nexport type AllGeoJSON =\n  | Feature\n  | FeatureCollection\n  | Geometry\n  | GeometryCollection;\n\n/**\n * @module helpers\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport const earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * Keys are the name of the unit, values are the number of that unit in a single radian\n *\n * @memberof helpers\n * @type {Object}\n */\nexport const factors: Record<Units, number> = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936,\n};\n\n/**\n\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport const areaFactors: Record<AreaUnits, number> = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  nauticalmiles: 2.9155334959812285e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046,\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geom: G | null,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<G, P> {\n  const feat: any = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(\n  type:\n    | \"Point\"\n    | \"LineString\"\n    | \"Polygon\"\n    | \"MultiPoint\"\n    | \"MultiLineString\"\n    | \"MultiPolygon\",\n  coordinates: any[],\n  _options: Record<string, never> = {}\n) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Point, P> {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  const geom: Point = {\n    type: \"Point\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Point, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Polygon, P> {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom: Polygon = {\n    type: \"Polygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Polygon, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<LineString, P> {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom: LineString = {\n    type: \"LineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<LineString, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  features: Array<Feature<G, P>>,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<G, P> {\n  const fc: any = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiLineString, P> {\n  const geom: MultiLineString = {\n    type: \"MultiLineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPoint, P> {\n  const geom: MultiPoint = {\n    type: \"MultiPoint\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPolygon, P> {\n  const geom: MultiPolygon = {\n    type: \"MultiPolygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geometries: Array<\n    Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon\n  >,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<GeometryCollection, P> {\n  const geom: GeometryCollection = {\n    type: \"GeometryCollection\",\n    geometries,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num: number, precision = 0): number {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(\n  radians: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(\n  distance: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance: number, units?: Units): number {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing: number): number {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  const degrees = radians % (2 * Math.PI);\n  return (degrees * 180) / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees: number): number {\n  const radians = degrees % 360;\n  return (radians * Math.PI) / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(\n  length: number,\n  originalUnit: Units = \"kilometers\",\n  finalUnit: Units = \"kilometers\"\n): number {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(\n  area: number,\n  originalUnit: AreaUnits = \"meters\",\n  finalUnit: AreaUnits = \"kilometers\"\n): number {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num: any): boolean {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false, including false for Arrays and Functions\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input: any): boolean {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws {Error} if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox: any): void {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws {Error} if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id: any): void {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n"],"mappings":"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","names":[]}