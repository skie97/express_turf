{"version":3,"sources":["../../index.ts"],"names":[],"mappings":";;;;AASA,SAAS,QAAQ,gBAAgB;AACjC,SAAS,WAAW,eAAe;AACnC,SAAS,SAAS,cAAc,kBAAkB;AAClD,SAAS,aAAa;AAqBtB,SAAS,cACP,OACA,UAKI,CAAC,GACL;AAzCF;AA2CE,MAAI,aAAa,QAAQ;AACzB,MAAI,gBAAe,aAAQ,iBAAR,YAAwB;AAC3C,MAAI,eAAc,aAAQ,gBAAR,YAAuB;AACzC,MAAI,UAAS,aAAQ,WAAR,YAAkB;AAE/B,MAAI,CAAC,QAAQ;AACX,YAAQ,MAAM,KAAK;AAAA,EACrB;AAEA,UAAQ,MAAM,MAAM;AAAA,IAClB,KAAK;AACH,UAAI,SAAyB,CAAC;AAC9B,YAAM,SAAS,QAAQ,SAAU,MAAM;AACrC,eAAO;AAAA,UACL,UAAU,oBAAoB,MAAM,CAAC,GAAG,cAAc,WAAW,CAAC;AAAA,QACpE;AAAA,MACF,CAAC;AACD,aAAO,aAAa,QAAQ,UAAU;AAAA,IACxC;AACE,aAAO,oBAAoB,OAAO,YAAY,cAAc,WAAW;AAAA,EAC3E;AACF;AA/BS;AA2CT,SAAS,oBACP,MACA,YACA,cACA,aACA;AACA,eAAa,aACT,aACA,KAAK,SAAS,YACZ,KAAK,aACL,CAAC;AACP,MAAI,OAAO,QAAQ,IAAI;AACvB,MAAI,SAAoC,KAAK;AAC7C,MAAI,OAAO,KAAK;AAEhB,MAAI,CAAC,OAAO;AAAQ,UAAM,IAAI,MAAM,+BAA+B;AAEnE,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,UAAI;AAAc,iBAAS,mBAAmB,MAAoB;AAClE,aAAO,QAAQ,CAAC,MAAoB,GAAG,UAAU;AAAA,IACnD,KAAK;AACH,UAAI,cAA4B,CAAC;AACjC,UAAI,cAAc;AAElB,MAAC,OAAwB,QAAQ,SAAU,OAAO;AAChD,YAAI;AAAc,kBAAQ,mBAAmB,KAAK;AAGlD,YAAI,aAAa;AACf,cAAI,OAAO,cAAc,SAAS,WAAW,KAAK,CAAC,CAAC;AACpD,cAAI,OAAO,aAAa;AACtB,wBAAY,QAAQ,KAAK;AACzB,0BAAc;AAAA,UAChB;AAAO,wBAAY,KAAK,KAAK;AAAA,QAC/B,OAAO;AACL,sBAAY,KAAK,KAAK;AAAA,QACxB;AAAA,MACF,CAAC;AACD,aAAO,QAAQ,aAAa,UAAU;AAAA,IACxC;AACE,YAAM,IAAI,MAAM,mBAAmB,OAAO,mBAAmB;AAAA,EACjE;AACF;AA3CS;AAoDT,SAAS,mBAAmB,QAAoB;AAC9C,MAAI,QAAQ,OAAO,CAAC;AACpB,MAAI,KAAK,MAAM,CAAC;AAChB,MAAI,KAAK,MAAM,CAAC;AAChB,MAAI,OAAO,OAAO,OAAO,SAAS,CAAC;AACnC,MAAI,KAAK,KAAK,CAAC;AACf,MAAI,KAAK,KAAK,CAAC;AACf,MAAI,OAAO,MAAM,OAAO,IAAI;AAC1B,WAAO,KAAK,KAAK;AAAA,EACnB;AACA,SAAO;AACT;AAXS;AAoBT,SAAS,cAAc,MAAY;AACjC,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAClB,MAAI,OAAO,KAAK,CAAC;AACjB,MAAI,QAAQ,KAAK,CAAC;AAClB,SAAO,KAAK,IAAI,OAAO,IAAI,IAAI,KAAK,IAAI,QAAQ,KAAK;AACvD;AANS;AAST,IAAO,+BAAQ","sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  MultiLineString,\n  LineString,\n  GeoJsonProperties,\n  BBox,\n  Position,\n} from \"geojson\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @name lineToPolygon\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon<G extends LineString | MultiLineString>(\n  lines: Feature<G> | FeatureCollection<G> | G,\n  options: {\n    properties?: GeoJsonProperties;\n    autoComplete?: boolean;\n    orderCoords?: boolean;\n    mutate?: boolean;\n  } = {}\n) {\n  // Optional parameters\n  var properties = options.properties;\n  var autoComplete = options.autoComplete ?? true;\n  var orderCoords = options.orderCoords ?? true;\n  var mutate = options.mutate ?? false;\n\n  if (!mutate) {\n    lines = clone(lines);\n  }\n\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords: number[][][][] = [];\n      lines.features.forEach(function (line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon<G extends LineString | MultiLineString>(\n  line: Feature<G> | G,\n  properties: GeoJsonProperties | undefined,\n  autoComplete: boolean,\n  orderCoords: boolean\n) {\n  properties = properties\n    ? properties\n    : line.type === \"Feature\"\n      ? line.properties\n      : {};\n  var geom = getGeom(line);\n  var coords: Position[] | Position[][] = geom.coordinates;\n  var type = geom.type;\n\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords as Position[]);\n      return polygon([coords as Position[]], properties);\n    case \"MultiLineString\":\n      var multiCoords: number[][][] = [];\n      var largestArea = 0;\n\n      (coords as Position[][]).forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n\n        // Largest LineString to be placed in the first position of the coordinates array\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords: Position[]) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\n\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox: BBox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\n\nexport { lineToPolygon };\nexport default lineToPolygon;\n"]}