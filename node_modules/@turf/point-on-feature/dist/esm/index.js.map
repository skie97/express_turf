{"version":3,"sources":["../../index.ts"],"sourcesContent":["import type { Feature, Point } from \"geojson\";\nimport type { AllGeoJSON } from \"@turf/helpers\";\nimport { explode } from \"@turf/explode\";\nimport { center as centroid } from \"@turf/center\";\nimport { nearestPoint } from \"@turf/nearest-point\";\nimport { booleanPointInPolygon } from \"@turf/boolean-point-in-polygon\";\nimport { featureCollection, feature, point } from \"@turf/helpers\";\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson: AllGeoJSON): Feature<Point> {\n  // normalize\n  const fc = normalize(geojson);\n\n  // get centroid\n  const cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  let onSurface = false;\n  let i = 0;\n  while (!onSurface && i < fc.features.length) {\n    const geom = fc.features[i].geometry;\n    let x, y, x1, y1, x2, y2;\n    let onLine = false;\n    if (geom.type === \"Point\") {\n      if (\n        cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]\n      ) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      let onMultiPoint = false;\n      let k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (\n          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]\n        ) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      let k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      let j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        let k = 0;\n        const line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    const vertices = featureCollection<Point>([]);\n    for (let f = 0; f < fc.features.length; f++) {\n      vertices.features = vertices.features.concat(\n        explode(fc.features[f]).features\n      );\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson: AllGeoJSON) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\n\nfunction pointOnSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n) {\n  const ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  const pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport { pointOnFeature };\nexport default pointOnFeature;\n"],"mappings":"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","names":[]}