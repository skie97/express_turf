{"version":3,"sources":["../../index.js"],"names":["mask"],"mappings":";;;;AAAA,SAAS,WAAW,eAAe,oBAAoB;AACvD,OAAO,qBAAqB;AAkB5B,SAAS,KAAK,SAASA,OAAM;AAE3B,MAAI,cAAc,WAAWA,KAAI;AAEjC,MAAI,gBAAgB;AACpB,MAAI,QAAQ,SAAS;AAAqB,oBAAgB,QAAQ,OAAO;AAAA;AAEvE,oBAAgB;AAAA,MACd,gBAAgB,MAAM,QAAQ,SAAS,WAAW;AAAA,IACpD;AAEF,gBAAc,SAAS,YAAY,QAAQ,SAAU,SAAS;AAC5D,gBAAY,SAAS,YAAY,KAAK,QAAQ,CAAC,CAAC;AAAA,EAClD,CAAC;AAED,SAAO;AACT;AAhBS;AAkBT,SAAS,QAAQ,IAAI;AACnB,MAAI,UACF,GAAG,SAAS,WAAW,IACnB,gBAAgB;AAAA,IACd,GAAG,SAAS,CAAC,EAAE,SAAS;AAAA,IACxB,GAAG,SAAS,CAAC,EAAE,SAAS;AAAA,EAC1B,IACA,gBAAgB,MAAM;AAAA,IACpB;AAAA,IACA,GAAG,SAAS,IAAI,SAAU,GAAG;AAC3B,aAAO,EAAE,SAAS;AAAA,IACpB,CAAC;AAAA,EACH;AACN,SAAO,oCAAoC,OAAO;AACpD;AAdS;AAgBT,SAAS,oCAAoC,SAAS;AACpD,SAAO,aAAa,OAAO;AAC7B;AAFS;AAWT,SAAS,WAAWA,OAAM;AACxB,MAAI,QAAQ;AAAA,IACV;AAAA,MACE,CAAC,KAAK,EAAE;AAAA,MACR,CAAC,MAAM,EAAE;AAAA,MACT,CAAC,MAAM,GAAG;AAAA,MACV,CAAC,KAAK,GAAG;AAAA,MACT,CAAC,KAAK,EAAE;AAAA,IACV;AAAA,EACF;AACA,MAAI,cAAeA,SAAQA,MAAK,SAAS,eAAgB;AACzD,SAAO,cAAc,WAAW;AAClC;AAZS;AAeT,IAAO,oBAAQ","sourcesContent":["import { polygon as createPolygon, multiPolygon } from \"@turf/helpers\";\nimport polygonClipping from \"polygon-clipping\";\n\n/**\n * Takes any type of {@link Polygon|polygon} and an optional mask and returns a {@link Polygon|polygon} exterior ring with holes.\n *\n * @name mask\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} polygon GeoJSON Polygon used as interior rings or holes.\n * @param {Feature<Polygon>} [mask] GeoJSON Polygon used as the exterior ring (if undefined, the world extent is used)\n * @returns {Feature<Polygon>} Masked Polygon (exterior ring with holes).\n * @example\n * var polygon = turf.polygon([[[112, -21], [116, -36], [146, -39], [153, -24], [133, -10], [112, -21]]]);\n * var mask = turf.polygon([[[90, -55], [170, -55], [170, 10], [90, 10], [90, -55]]]);\n *\n * var masked = turf.mask(polygon, mask);\n *\n * //addToMap\n * var addToMap = [masked]\n */\nfunction mask(polygon, mask) {\n  // Define mask\n  var maskPolygon = createMask(mask);\n\n  var polygonOuters = null;\n  if (polygon.type === \"FeatureCollection\") polygonOuters = unionFc(polygon);\n  else\n    polygonOuters = createGeomFromPolygonClippingOutput(\n      polygonClipping.union(polygon.geometry.coordinates)\n    );\n\n  polygonOuters.geometry.coordinates.forEach(function (contour) {\n    maskPolygon.geometry.coordinates.push(contour[0]);\n  });\n\n  return maskPolygon;\n}\n\nfunction unionFc(fc) {\n  var unioned =\n    fc.features.length === 2\n      ? polygonClipping.union(\n          fc.features[0].geometry.coordinates,\n          fc.features[1].geometry.coordinates\n        )\n      : polygonClipping.union.apply(\n          polygonClipping,\n          fc.features.map(function (f) {\n            return f.geometry.coordinates;\n          })\n        );\n  return createGeomFromPolygonClippingOutput(unioned);\n}\n\nfunction createGeomFromPolygonClippingOutput(unioned) {\n  return multiPolygon(unioned);\n}\n\n/**\n * Create Mask Coordinates\n *\n * @private\n * @param {Feature<Polygon>} [mask] default to world if undefined\n * @returns {Feature<Polygon>} mask coordinate\n */\nfunction createMask(mask) {\n  var world = [\n    [\n      [180, 90],\n      [-180, 90],\n      [-180, -90],\n      [180, -90],\n      [180, 90],\n    ],\n  ];\n  var coordinates = (mask && mask.geometry.coordinates) || world;\n  return createPolygon(coordinates);\n}\n\nexport { mask };\nexport default mask;\n"]}