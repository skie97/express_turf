"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.ts
var _lineintersect = require('@turf/line-intersect');
var _polygontoline = require('@turf/polygon-to-line');
var _booleanpointinpolygon = require('@turf/boolean-point-in-polygon');
var _invariant = require('@turf/invariant');
var _helpers = require('@turf/helpers');
function booleanCrosses(feature1, feature2) {
  var geom1 = _invariant.getGeom.call(void 0, feature1);
  var geom2 = _invariant.getGeom.call(void 0, feature2);
  var type1 = geom1.type;
  var type2 = geom2.type;
  switch (type1) {
    case "MultiPoint":
      switch (type2) {
        case "LineString":
          return doMultiPointAndLineStringCross(geom1, geom2);
        case "Polygon":
          return doesMultiPointCrossPoly(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "LineString":
      switch (type2) {
        case "MultiPoint":
          return doMultiPointAndLineStringCross(geom2, geom1);
        case "LineString":
          return doLineStringsCross(geom1, geom2);
        case "Polygon":
          return doLineStringAndPolygonCross(geom1, geom2);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    case "Polygon":
      switch (type2) {
        case "MultiPoint":
          return doesMultiPointCrossPoly(geom2, geom1);
        case "LineString":
          return doLineStringAndPolygonCross(geom2, geom1);
        default:
          throw new Error("feature2 " + type2 + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + type1 + " geometry not supported");
  }
}
__name(booleanCrosses, "booleanCrosses");
function doMultiPointAndLineStringCross(multiPoint, lineString) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint.coordinates.length;
  var i = 0;
  while (i < pointLength && !foundIntPoint && !foundExtPoint) {
    for (var i2 = 0; i2 < lineString.coordinates.length - 1; i2++) {
      var incEndVertices = true;
      if (i2 === 0 || i2 === lineString.coordinates.length - 2) {
        incEndVertices = false;
      }
      if (isPointOnLineSegment(
        lineString.coordinates[i2],
        lineString.coordinates[i2 + 1],
        multiPoint.coordinates[i],
        incEndVertices
      )) {
        foundIntPoint = true;
      } else {
        foundExtPoint = true;
      }
    }
    i++;
  }
  return foundIntPoint && foundExtPoint;
}
__name(doMultiPointAndLineStringCross, "doMultiPointAndLineStringCross");
function doLineStringsCross(lineString1, lineString2) {
  var doLinesIntersect = _lineintersect.lineIntersect.call(void 0, lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    for (var i = 0; i < lineString1.coordinates.length - 1; i++) {
      for (var i2 = 0; i2 < lineString2.coordinates.length - 1; i2++) {
        var incEndVertices = true;
        if (i2 === 0 || i2 === lineString2.coordinates.length - 2) {
          incEndVertices = false;
        }
        if (isPointOnLineSegment(
          lineString1.coordinates[i],
          lineString1.coordinates[i + 1],
          lineString2.coordinates[i2],
          incEndVertices
        )) {
          return true;
        }
      }
    }
  }
  return false;
}
__name(doLineStringsCross, "doLineStringsCross");
function doLineStringAndPolygonCross(lineString, polygon) {
  const line = _polygontoline.polygonToLine.call(void 0, polygon);
  const doLinesIntersect = _lineintersect.lineIntersect.call(void 0, lineString, line);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
__name(doLineStringAndPolygonCross, "doLineStringAndPolygonCross");
function doesMultiPointCrossPoly(multiPoint, polygon) {
  var foundIntPoint = false;
  var foundExtPoint = false;
  var pointLength = multiPoint.coordinates.length;
  for (let i = 0; i < pointLength && (!foundIntPoint || !foundExtPoint); i++) {
    if (_booleanpointinpolygon.booleanPointInPolygon.call(void 0, _helpers.point.call(void 0, multiPoint.coordinates[i]), polygon)) {
      foundIntPoint = true;
    } else {
      foundExtPoint = true;
    }
  }
  return foundExtPoint && foundIntPoint;
}
__name(doesMultiPointCrossPoly, "doesMultiPointCrossPoly");
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, incEnd) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (incEnd) {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0] : lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1] : lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  } else {
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      return dxl > 0 ? lineSegmentStart[0] < pt[0] && pt[0] < lineSegmentEnd[0] : lineSegmentEnd[0] < pt[0] && pt[0] < lineSegmentStart[0];
    }
    return dyl > 0 ? lineSegmentStart[1] < pt[1] && pt[1] < lineSegmentEnd[1] : lineSegmentEnd[1] < pt[1] && pt[1] < lineSegmentStart[1];
  }
}
__name(isPointOnLineSegment, "isPointOnLineSegment");
var turf_boolean_crosses_default = booleanCrosses;



exports.booleanCrosses = booleanCrosses; exports.default = turf_boolean_crosses_default;
//# sourceMappingURL=index.cjs.map