{"version":3,"sources":["../../index.js"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,aAAa;AACtB,SAAS,wBAAwB;AAuBjC,SAAS,mBAAmB,SAAS,UAAU,WAAW,SAAS;AAEjE,YAAU,WAAW,CAAC;AACtB,MAAI,CAAC,SAAS,OAAO;AAAG,UAAM,IAAI,MAAM,oBAAoB;AAC5D,MAAI,QAAQ,QAAQ;AACpB,MAAI,eAAe,QAAQ;AAC3B,MAAI,SAAS,QAAQ;AAGrB,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,qBAAqB;AACnD,MAAI,aAAa,UAAa,aAAa,QAAQ,MAAM,QAAQ;AAC/D,UAAM,IAAI,MAAM,sBAAsB;AACxC,MAAI,gBAAgB,OAAO,iBAAiB,YAAY,MAAM,YAAY;AACxE,UAAM,IAAI,MAAM,8BAA8B;AAGhD,iBAAe,iBAAiB,SAAY,eAAe;AAC3D,MAAI,aAAa,KAAK,iBAAiB;AAAG,WAAO;AAEjD,MAAI,cAAc,UAAa,cAAc,QAAQ,MAAM,SAAS;AAClE,UAAM,IAAI,MAAM,uBAAuB;AAGzC,MAAI,WAAW,GAAG;AAChB,eAAW,CAAC;AACZ,gBAAY,YAAY;AAAA,EAC1B;AAGA,MAAI,WAAW,SAAS,WAAW;AAAW,cAAU,MAAM,OAAO;AAGrE,YAAU,SAAS,SAAU,aAAa;AACxC,QAAI,YAAY;AAAA,MACd,iBAAiB,aAAa,UAAU,WAAW,EAAE,MAAa,CAAC;AAAA,IACrE;AACA,gBAAY,CAAC,IAAI,UAAU,CAAC;AAC5B,gBAAY,CAAC,IAAI,UAAU,CAAC;AAC5B,QAAI,gBAAgB,YAAY,WAAW;AACzC,kBAAY,CAAC,KAAK;AAAA,EACtB,CAAC;AACD,SAAO;AACT;AA1CS;AA6CT,IAAO,mCAAQ","sourcesContent":["import { coordEach } from \"@turf/meta\";\nimport { isObject } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { clone } from \"@turf/clone\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\n\n/**\n * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line\n * on the provided direction angle.\n *\n * @name transformTranslate\n * @param {GeoJSON} geojson object to be translated\n * @param {number} distance length of the motion; negative values determine motion in opposite direction\n * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians\n * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the translated GeoJSON object\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var translatedPoly = turf.transformTranslate(poly, 100, 35);\n *\n * //addToMap\n * var addToMap = [poly, translatedPoly];\n * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformTranslate(geojson, distance, direction, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var zTranslation = options.zTranslation;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n  if (zTranslation && typeof zTranslation !== \"number\" && isNaN(zTranslation))\n    throw new Error(\"zTranslation is not a number\");\n\n  // Shortcut no-motion\n  zTranslation = zTranslation !== undefined ? zTranslation : 0;\n  if (distance === 0 && zTranslation === 0) return geojson;\n\n  if (direction === undefined || direction === null || isNaN(direction))\n    throw new Error(\"direction is required\");\n\n  // Invert with negative distances\n  if (distance < 0) {\n    distance = -distance;\n    direction = direction + 180;\n  }\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Translate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    var newCoords = getCoords(\n      rhumbDestination(pointCoords, distance, direction, { units: units })\n    );\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n    if (zTranslation && pointCoords.length === 3)\n      pointCoords[2] += zTranslation;\n  });\n  return geojson;\n}\n\nexport { transformTranslate };\nexport default transformTranslate;\n"]}