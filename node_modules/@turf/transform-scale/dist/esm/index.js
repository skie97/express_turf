var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.js
import { clone } from "@turf/clone";
import { center } from "@turf/center";
import { centroid } from "@turf/centroid";
import { bbox as turfBBox } from "@turf/bbox";
import { rhumbBearing } from "@turf/rhumb-bearing";
import { rhumbDistance } from "@turf/rhumb-distance";
import { rhumbDestination } from "@turf/rhumb-destination";
import { coordEach, featureEach } from "@turf/meta";
import { point, isObject } from "@turf/helpers";
import { getCoord, getCoords, getType } from "@turf/invariant";
function transformScale(geojson, factor, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var origin = options.origin;
  var mutate = options.mutate;
  if (!geojson)
    throw new Error("geojson required");
  if (typeof factor !== "number" || factor <= 0)
    throw new Error("invalid factor");
  var originIsPoint = Array.isArray(origin) || typeof origin === "object";
  if (mutate !== true)
    geojson = clone(geojson);
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    featureEach(geojson, function(feature, index) {
      geojson.features[index] = scale(feature, factor, origin);
    });
    return geojson;
  }
  return scale(geojson, factor, origin);
}
__name(transformScale, "transformScale");
function scale(feature, factor, origin) {
  var isPoint = getType(feature) === "Point";
  origin = defineOrigin(feature, origin);
  if (factor === 1 || isPoint)
    return feature;
  coordEach(feature, function(coord) {
    var originalDistance = rhumbDistance(origin, coord);
    var bearing = rhumbBearing(origin, coord);
    var newDistance = originalDistance * factor;
    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3)
      coord[2] *= factor;
  });
  delete feature.bbox;
  return feature;
}
__name(scale, "scale");
function defineOrigin(geojson, origin) {
  if (origin === void 0 || origin === null)
    origin = "centroid";
  if (Array.isArray(origin) || typeof origin === "object")
    return getCoord(origin);
  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson, { recalculate: true });
  var west = bbox[0];
  var south = bbox[1];
  var east = bbox[2];
  var north = bbox[3];
  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return point([east, north]);
    case "center":
      return center(geojson);
    case void 0:
    case null:
    case "centroid":
      return centroid(geojson);
    default:
      throw new Error("invalid origin");
  }
}
__name(defineOrigin, "defineOrigin");
var turf_transform_scale_default = transformScale;
export {
  turf_transform_scale_default as default,
  transformScale
};
//# sourceMappingURL=index.js.map