var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.js
import { coordAll, featureEach } from "@turf/meta";
import { getCoords } from "@turf/invariant";
import { featureCollection, isObject, isNumber } from "@turf/helpers";
import { centerMean } from "@turf/center-mean";
import { pointsWithinPolygon } from "@turf/points-within-polygon";
import { ellipse } from "@turf/ellipse";
function standardDeviationalEllipse(points, options) {
  options = options || {};
  if (!isObject(options))
    throw new Error("options is invalid");
  var steps = options.steps || 64;
  var weightTerm = options.weight;
  var properties = options.properties || {};
  if (!isNumber(steps))
    throw new Error("steps must be a number");
  if (!isObject(properties))
    throw new Error("properties must be a number");
  var numberOfFeatures = coordAll(points).length;
  var meanCenter = centerMean(points, { weight: weightTerm });
  var xDeviationSquaredSum = 0;
  var yDeviationSquaredSum = 0;
  var xyDeviationSum = 0;
  featureEach(points, function(point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });
  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  var bigC = 2 * xyDeviationSum;
  var theta = Math.atan((bigA + bigB) / bigC);
  var thetaDeg = theta * 180 / Math.PI;
  var sigmaXsum = 0;
  var sigmaYsum = 0;
  var weightsum = 0;
  featureEach(points, function(point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));
    sigmaXsum += Math.pow(
      deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
      2
    ) * weight;
    sigmaYsum += Math.pow(
      deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
      2
    ) * weight;
    weightsum += weight;
  });
  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps,
    properties
  });
  var pointsWithinEllipse = pointsWithinPolygon(
    points,
    featureCollection([theEllipse])
  );
  var standardDeviationalEllipseProperties = {
    meanCenterCoordinates: getCoords(meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures
  };
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
  return theEllipse;
}
__name(standardDeviationalEllipse, "standardDeviationalEllipse");
function getDeviations(coordinates, center) {
  return {
    x: coordinates[0] - center[0],
    y: coordinates[1] - center[1]
  };
}
__name(getDeviations, "getDeviations");
var turf_standard_deviational_ellipse_default = standardDeviationalEllipse;
export {
  turf_standard_deviational_ellipse_default as default,
  standardDeviationalEllipse
};
//# sourceMappingURL=index.js.map