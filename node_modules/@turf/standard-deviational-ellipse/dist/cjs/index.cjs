"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// index.js
var _meta = require('@turf/meta');
var _invariant = require('@turf/invariant');
var _helpers = require('@turf/helpers');
var _centermean = require('@turf/center-mean');
var _pointswithinpolygon = require('@turf/points-within-polygon');
var _ellipse = require('@turf/ellipse');
function standardDeviationalEllipse(points, options) {
  options = options || {};
  if (!_helpers.isObject.call(void 0, options))
    throw new Error("options is invalid");
  var steps = options.steps || 64;
  var weightTerm = options.weight;
  var properties = options.properties || {};
  if (!_helpers.isNumber.call(void 0, steps))
    throw new Error("steps must be a number");
  if (!_helpers.isObject.call(void 0, properties))
    throw new Error("properties must be a number");
  var numberOfFeatures = _meta.coordAll.call(void 0, points).length;
  var meanCenter = _centermean.centerMean.call(void 0, points, { weight: weightTerm });
  var xDeviationSquaredSum = 0;
  var yDeviationSquaredSum = 0;
  var xyDeviationSum = 0;
  _meta.featureEach.call(void 0, points, function(point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(_invariant.getCoords.call(void 0, point), _invariant.getCoords.call(void 0, meanCenter));
    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;
    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;
    xyDeviationSum += deviation.x * deviation.y * weight;
  });
  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;
  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));
  var bigC = 2 * xyDeviationSum;
  var theta = Math.atan((bigA + bigB) / bigC);
  var thetaDeg = theta * 180 / Math.PI;
  var sigmaXsum = 0;
  var sigmaYsum = 0;
  var weightsum = 0;
  _meta.featureEach.call(void 0, points, function(point) {
    var weight = point.properties[weightTerm] || 1;
    var deviation = getDeviations(_invariant.getCoords.call(void 0, point), _invariant.getCoords.call(void 0, meanCenter));
    sigmaXsum += Math.pow(
      deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),
      2
    ) * weight;
    sigmaYsum += Math.pow(
      deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),
      2
    ) * weight;
    weightsum += weight;
  });
  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);
  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);
  var theEllipse = _ellipse.ellipse.call(void 0, meanCenter, sigmaX, sigmaY, {
    units: "degrees",
    angle: thetaDeg,
    steps,
    properties
  });
  var pointsWithinEllipse = _pointswithinpolygon.pointsWithinPolygon.call(void 0, 
    points,
    _helpers.featureCollection.call(void 0, [theEllipse])
  );
  var standardDeviationalEllipseProperties = {
    meanCenterCoordinates: _invariant.getCoords.call(void 0, meanCenter),
    semiMajorAxis: sigmaX,
    semiMinorAxis: sigmaY,
    numberOfFeatures,
    angle: thetaDeg,
    percentageWithinEllipse: 100 * _meta.coordAll.call(void 0, pointsWithinEllipse).length / numberOfFeatures
  };
  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;
  return theEllipse;
}
__name(standardDeviationalEllipse, "standardDeviationalEllipse");
function getDeviations(coordinates, center) {
  return {
    x: coordinates[0] - center[0],
    y: coordinates[1] - center[1]
  };
}
__name(getDeviations, "getDeviations");
var turf_standard_deviational_ellipse_default = standardDeviationalEllipse;



exports.default = turf_standard_deviational_ellipse_default; exports.standardDeviationalEllipse = standardDeviationalEllipse;
//# sourceMappingURL=index.cjs.map