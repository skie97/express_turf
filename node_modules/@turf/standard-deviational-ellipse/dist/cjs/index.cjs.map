{"version":3,"sources":["../../index.js"],"names":[],"mappings":";;;;AAAA,SAAS,UAAU,mBAAmB;AACtC,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB,UAAU,gBAAgB;AACtD,SAAS,kBAAkB;AAC3B,SAAS,2BAA2B;AACpC,SAAS,eAAe;AAwCxB,SAAS,2BAA2B,QAAQ,SAAS;AAEnD,YAAU,WAAW,CAAC;AACtB,MAAI,CAAC,SAAS,OAAO;AAAG,UAAM,IAAI,MAAM,oBAAoB;AAC5D,MAAI,QAAQ,QAAQ,SAAS;AAC7B,MAAI,aAAa,QAAQ;AACzB,MAAI,aAAa,QAAQ,cAAc,CAAC;AAGxC,MAAI,CAAC,SAAS,KAAK;AAAG,UAAM,IAAI,MAAM,wBAAwB;AAC9D,MAAI,CAAC,SAAS,UAAU;AAAG,UAAM,IAAI,MAAM,6BAA6B;AAGxE,MAAI,mBAAmB,SAAS,MAAM,EAAE;AACxC,MAAI,aAAa,WAAW,QAAQ,EAAE,QAAQ,WAAW,CAAC;AAS1D,MAAI,uBAAuB;AAC3B,MAAI,uBAAuB;AAC3B,MAAI,iBAAiB;AAErB,cAAY,QAAQ,SAAU,OAAO;AACnC,QAAI,SAAS,MAAM,WAAW,UAAU,KAAK;AAC7C,QAAI,YAAY,cAAc,UAAU,KAAK,GAAG,UAAU,UAAU,CAAC;AACrE,4BAAwB,KAAK,IAAI,UAAU,GAAG,CAAC,IAAI;AACnD,4BAAwB,KAAK,IAAI,UAAU,GAAG,CAAC,IAAI;AACnD,sBAAkB,UAAU,IAAI,UAAU,IAAI;AAAA,EAChD,CAAC;AAED,MAAI,OAAO,uBAAuB;AAClC,MAAI,OAAO,KAAK,KAAK,KAAK,IAAI,MAAM,CAAC,IAAI,IAAI,KAAK,IAAI,gBAAgB,CAAC,CAAC;AACxE,MAAI,OAAO,IAAI;AACf,MAAI,QAAQ,KAAK,MAAM,OAAO,QAAQ,IAAI;AAC1C,MAAI,WAAY,QAAQ,MAAO,KAAK;AAKpC,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,cAAY,QAAQ,SAAU,OAAO;AACnC,QAAI,SAAS,MAAM,WAAW,UAAU,KAAK;AAC7C,QAAI,YAAY,cAAc,UAAU,KAAK,GAAG,UAAU,UAAU,CAAC;AACrE,iBACE,KAAK;AAAA,MACH,UAAU,IAAI,KAAK,IAAI,KAAK,IAAI,UAAU,IAAI,KAAK,IAAI,KAAK;AAAA,MAC5D;AAAA,IACF,IAAI;AACN,iBACE,KAAK;AAAA,MACH,UAAU,IAAI,KAAK,IAAI,KAAK,IAAI,UAAU,IAAI,KAAK,IAAI,KAAK;AAAA,MAC5D;AAAA,IACF,IAAI;AACN,iBAAa;AAAA,EACf,CAAC;AAED,MAAI,SAAS,KAAK,KAAM,IAAI,YAAa,SAAS;AAClD,MAAI,SAAS,KAAK,KAAM,IAAI,YAAa,SAAS;AAElD,MAAI,aAAa,QAAQ,YAAY,QAAQ,QAAQ;AAAA,IACnD,OAAO;AAAA,IACP,OAAO;AAAA,IACP;AAAA,IACA;AAAA,EACF,CAAC;AACD,MAAI,sBAAsB;AAAA,IACxB;AAAA,IACA,kBAAkB,CAAC,UAAU,CAAC;AAAA,EAChC;AACA,MAAI,uCAAuC;AAAA,IACzC,uBAAuB,UAAU,UAAU;AAAA,IAC3C,eAAe;AAAA,IACf,eAAe;AAAA,IACf;AAAA,IACA,OAAO;AAAA,IACP,yBACG,MAAM,SAAS,mBAAmB,EAAE,SAAU;AAAA,EACnD;AACA,aAAW,WAAW,6BACpB;AAEF,SAAO;AACT;AAzFS;AAmGT,SAAS,cAAc,aAAa,QAAQ;AAC1C,SAAO;AAAA,IACL,GAAG,YAAY,CAAC,IAAI,OAAO,CAAC;AAAA,IAC5B,GAAG,YAAY,CAAC,IAAI,OAAO,CAAC;AAAA,EAC9B;AACF;AALS;AAQT,IAAO,4CAAQ","sourcesContent":["import { coordAll, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject, isNumber } from \"@turf/helpers\";\nimport { centerMean } from \"@turf/center-mean\";\nimport { pointsWithinPolygon } from \"@turf/points-within-polygon\";\nimport { ellipse } from \"@turf/ellipse\";\n\n/**\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\n * also known as a “directional distribution.” The standard deviational ellipse\n * aims to show the direction and the distribution of a dataset by drawing\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\n * data.\n *\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\n *\n * **Bibliography**\n *\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\n *\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\n *\n *\n * @name standardDeviationalEllipse\n * @param {FeatureCollection<Point>} points GeoJSON points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.steps=64] number of steps for the polygon\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\n * @example\n *\n * var bbox = [-74, 40.72, -73.98, 40.74];\n * var points = turf.randomPoint(400, {bbox: bbox});\n * var sdEllipse = turf.standardDeviationalEllipse(points);\n *\n * //addToMap\n * var addToMap = [points, sdEllipse];\n *\n */\nfunction standardDeviationalEllipse(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {};\n\n  // Validation:\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n\n  // Calculate mean center & number of features:\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, { weight: weightTerm });\n\n  // Calculate angle of rotation:\n  // [X, Y] = mean center of all [x, y].\n  // theta = arctan( (A + B) / C )\n  // A = sum((x - X)^2) - sum((y - Y)^2)\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\n  // C = 2(sum((x - X)(y - Y)))\n\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = (theta * 180) / Math.PI;\n\n  // Calculate axes:\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum +=\n      Math.pow(\n        deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),\n        2\n      ) * weight;\n    sigmaYsum +=\n      Math.pow(\n        deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),\n        2\n      ) * weight;\n    weightsum += weight;\n  });\n\n  var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);\n  var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);\n\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps: steps,\n    properties: properties,\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(\n    points,\n    featureCollection([theEllipse])\n  );\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures: numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse:\n      (100 * coordAll(pointsWithinEllipse).length) / numberOfFeatures,\n  };\n  theEllipse.properties.standardDeviationalEllipse =\n    standardDeviationalEllipseProperties;\n\n  return theEllipse;\n}\n\n/**\n * Get x_i - X and y_i - Y\n *\n * @private\n * @param {Array} coordinates Array of [x_i, y_i]\n * @param {Array} center Array of [X, Y]\n * @returns {Object} { x: n, y: m }\n */\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1],\n  };\n}\n\nexport { standardDeviationalEllipse };\nexport default standardDeviationalEllipse;\n"]}