{"version":3,"sources":["../../index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AASA,SAAS,eAAe;AACxB,SAAS,aAAa,gBAAgB;AACtC,SAAS,2BAA2B;AAyBpC,SAAS,mBACP,QAIA,MACA,UAGI,CAAC,GACc;AACnB,QAAM,QAAQ,QAAQ;AACtB,QAAM,aAAa,QAAQ,cAAc,CAAC;AAG1C,QAAM,MAAM,UAAU,MAAM;AAC5B,MAAI,CAAC,IAAI,SAAS,QAAQ;AACxB,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAEA,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AACA,MAAI,QAAQ,IAAI,MAAM,cAAc;AAClC,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AAEA,MAAI,OAAO;AACX,MAAI,KAAU;AAEd,cAAY,KAAK,CAAC,UAAU;AAC1B,UAAM,IAAI,oBAAoB,OAAO,MAAM,EAAE,MAAM,CAAC;AACpD,QAAI,IAAI,MAAM;AACZ,aAAO;AACP,WAAK;AAAA,IACP;AAAA,EACF,CAAC;AAOD,MAAI,IAAI;AACN,OAAG,aAAa,iDAAK,EAAE,KAAK,IAAM,GAAG,aAAe;AAAA,EACtD;AACA,SAAO;AACT;AA/CS;AAwDT,SAAS,UAAU,QAAuC;AACxD,QAAM,WAAkB,CAAC;AACzB,QAAM,OAAO,OAAO,WAAW,OAAO,SAAS,OAAO,OAAO;AAC7D,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,eAAS,QAAQ,CAAC,SAAS;AACzB,YAAI,KAAK,SAAS,SAAS;AACzB,mBAAS,KAAK,EAAE,MAAM,WAAW,YAAY,CAAC,GAAG,UAAU,KAAK,CAAC;AAAA,QACnE;AAAA,MACF,CAAC;AACD,aAAO,EAAE,MAAM,qBAAqB,SAAS;AAAA,IAC/C,KAAK;AACH,aAAO,WAAW,OAAO,SAAS,OAAO,CAAC,YAAiB;AACzD,eAAO,QAAQ,SAAS,SAAS;AAAA,MACnC,CAAC;AACD,aAAO;AAAA,IACT;AACE,YAAM,IAAI,MAAM,mCAAmC;AAAA,EACvD;AACF;AAnBS;AAsBT,IAAO,qCAAQ","sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  GeometryCollection,\n  LineString,\n  Point,\n  GeoJsonProperties,\n} from \"geojson\";\nimport { Units } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport { pointToLineDistance } from \"@turf/point-to-line-distance\";\n\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @name nearestPointToLine\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine<P = { dist: number; [key: string]: any }>(\n  points:\n    | FeatureCollection<Point>\n    | Feature<GeometryCollection>\n    | GeometryCollection,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    properties?: GeoJsonProperties;\n  } = {}\n): Feature<Point, P> {\n  const units = options.units;\n  const properties = options.properties || {};\n\n  // validation\n  const pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n\n  let dist = Infinity;\n  let pt: any = null;\n\n  featureEach(pts, (point) => {\n    const d = pointToLineDistance(point, line, { units });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  /**\n   * Translate Properties to final Point, priorities:\n   * 1. options.properties\n   * 2. inherent Point properties\n   * 3. dist custom properties created by NearestPointToLine\n   */\n  if (pt) {\n    pt.properties = { ...{ dist }, ...pt.properties, ...properties };\n  }\n  return pt;\n}\n\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points: any): FeatureCollection<Point> {\n  const features: any[] = [];\n  const type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, (geom) => {\n        if (geom.type === \"Point\") {\n          features.push({ type: \"Feature\", properties: {}, geometry: geom });\n        }\n      });\n      return { type: \"FeatureCollection\", features };\n    case \"FeatureCollection\":\n      points.features = points.features.filter((feature: any) => {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\n\nexport { nearestPointToLine };\nexport default nearestPointToLine;\n"]}